<html>
    <head>
        <style>
            #tooltip {
                background-color:white;
                border:1px solid blue;
                position:absolute;
                left:-200px;
                top:100px;
            }
            .tooltip-divider {
                border-bottom: 1px solid #ccc;
            }
            .tooltip-cat {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="1000" height="500" style="border:1px solid #d3d3d3;">
        </canvas>
        <canvas id="tooltip" width=100 height=25></canvas>
    </body>

    <script>
        // Sample data
        const data = [{
            x: 'Apple', y: 110
        }, {
            x: 'Samsung', y: 125
        }, {
            x: 'LG', y: 200
        }, {
            x: 'Hier', y: 250
        }, {
            x: 'Vivo', y: 223
        }, {
            x: 'Oppo', y: 187
        }, {
            x: 'Sony', y: 110
        }, {
            x: 'Nokia', y: 200
        }, {
            x: 'Asus', y: 1
        }, {
            x: 'Lenovo', y: 190
        }];
        // const tooltipTemplate = '<div>' +
        //     '<div class="tooltip-cat">@m=x</div>' +
        //     '<div class="tooltip-divider"></div>' +
        //     '<div class="tooltip-cat">@m=y</div>' +
        //     '</div>';
        const tooltipTemplate = null;
        const elementId = 'myCanvas';
        const tooltipCanvasId = 'tooltip';
        const graphElement = document.getElementById(elementId);
        const ctx = graphElement.getContext("2d");
        const tooltipCanvas = document.getElementById(tooltipCanvasId);
        const tooltipCtx = tooltipCanvas.getContext("2d");
        // predefined variables
        const yKey = 'y'; // Y axis key from data
        const xKey = 'x'; // X axis key from data
        const boxHeight = graphElement.clientHeight;
        const boxWidth = graphElement.clientWidth;
        let xAxisPadding = 50; // Padding from bottom
        const yAxisPadding = 50; // Padding from left
        const topPadding = 20;
        const xAxisNegativeValuePadding = 20;
        const columnPadding = 5; // Right and left padding of column
        let yAxisInterval = 50; // NOTE: For now taken static and need to make it dynamic
        let maxNegative = 0;
        let totalNegativeValues = 0;
        let xAxisPosition = 0;
        let actualInterval = 0;
        let maxX = getMaxX();
        let maxY = getMaxY();
        const xAxisInterval = getXAxisInterval(); // x axis interval
        if(maxNegative < 0) {
            xAxisPadding = xAxisNegativeValuePadding;
        }
        // Interval range from negative to positive for Y axis
        let intervalRange = [];
        let tooltipData = [];

        /*
         * Get range from maximum negative value to maximum positive values of predefined intervals
         */
        function getRange() {
            for(let i=0; i > maxNegative - yAxisInterval; i-=yAxisInterval) {
                intervalRange.push(i);
            }
            intervalRange.reverse();
            for(let i=yAxisInterval; i < maxY + yAxisInterval; i += yAxisInterval) {
                intervalRange.push(i);
            }
            return intervalRange;
        }

        // Returns the max Y value in our data list
        function getMaxY() {
            let max = 0;
            for (var i = 0; i < data.length; i++) {
                if (data[i][yKey] > max) {
                    max = data[i][yKey];
                }
                if(data[i][yKey] < 0) {
                    if(data[i][yKey]< maxNegative) {
                        maxNegative = data[i][yKey];
                        totalNegativeValues++;
                    }
                }
            }
            // max += 10 - max % 10;
            maxNegative = Math.floor(maxNegative/100)*100;
            return Math.ceil(max/100)*100;
        }

        // Returns the max X value in our data list
        function getMaxX() {
            return data.length;
        }
        // Return the x pixel for a graph point
        function getXMiddlePixel(val) {
            return yAxisPadding + (val * xAxisInterval) + (xAxisInterval / 2);
        }

        // Get starting position of column for X axis
        function getXStartingPixcel(val) {
            return yAxisPadding + (val * xAxisInterval) + columnPadding;
        }

        // Get X axis intervals
        function getXAxisInterval() {
            return ((boxWidth - yAxisPadding) / (maxX));
        }

        // Return the y pixel for a graph point
        function getYPixel(val) {
            const yPosition = xAxisPosition - (((xAxisPosition - topPadding - actualInterval) / maxY) * val);
            return yPosition;
        }

        // Generate X axis labels
        function generateXAxisLabel(yPosition) {
            var myMaxX = maxX;
            for (var i = 0; i < myMaxX; i++) {
                ctx.fillStyle = '#000';
                ctx.textAlign = "center";
                ctx.fillText(data[i][xKey], getXMiddlePixel(i), yPosition + 20);
                ctx.lineWidth = 2;
                ctx.moveTo(getXMiddlePixel(i), yPosition);
                ctx.lineTo(getXMiddlePixel(i), yPosition + 5);
                ctx.stroke();
            }
        }

        function drawYAxis() {
            // Draw y axis
            // ctx.beginPath();
            ctx.lineWidth = 0.1;
            ctx.moveTo(yAxisPadding, 0);
            ctx.lineTo(yAxisPadding, boxHeight);
            ctx.stroke();
        }

        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function generateColumns() {
            for(var i=0; i<data.length; i++) {
                ctx.beginPath();
                const width = xAxisInterval - (2 * columnPadding);
                const height = xAxisPosition - getYPixel(data[i][yKey]);
                const randomColor = getRandomColor();
                const grd = ctx.createLinearGradient(getXStartingPixcel(i), getYPixel(data[i][yKey]) + height + 40, getXStartingPixcel(i), getYPixel(data[i][yKey]));
                // grd.addColorStop(0, randomColor);
                grd.addColorStop(0, 'white');
                grd.addColorStop(1, randomColor);
                ctx.fillStyle = grd;
                // ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.globalAlpha = 0.9;
                ctx.fillRect(getXStartingPixcel(i), getYPixel(data[i][yKey]), width, height);

                // Add tooltip data
                let tooltipObj = {
                    x: getXStartingPixcel(i),
                    y: getYPixel(getYPixel(data[i][yKey])),
                    x1: getXStartingPixcel(i) + width,
                    y1: xAxisPosition,
                    data: data[i],
                    style: {
                        color: randomColor
                    }
                };
                tooltipData.push(tooltipObj);
                // ctx.fillStyle = getRandomColor();
                // ctx.fill();
            }
        }

        function drawHorizontalLines() {
            for(let i=0; i<intervalRange.length; i++) {
                ctx.lineWidth = 0.01;
                const intervalValue = (boxHeight - xAxisPadding - topPadding) / intervalRange.length;
                actualInterval = intervalValue;
                const yAxisPoint = boxHeight - xAxisPadding - (i * intervalValue);
                let yPadding = yAxisPadding;
                if(intervalRange[i] === 0) {
                    yPadding = 0;
                    xAxisPosition = yAxisPoint;
                }
                ctx.moveTo(yPadding, yAxisPoint);
                ctx.lineTo(boxWidth, yAxisPoint);
                ctx.stroke();
                ctx.font='bold 12px Roboto';
                ctx.fillText(intervalRange[i], yAxisPadding - 25, yAxisPoint);
            }
        }

        function renderHTMLToCanvas(html, x, y, width, height) {
            const data = '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                '<foreignObject width="100%" height="100%">' +
                '<div xmlns="http://www.w3.org/1999/xhtml">' +
                html +
                '</div>' +
                '</foreignObject>' +
                '</svg>';

            const DOMURL = window.URL || window.webkitURL || window;

            let img = new Image();
            const svg = new Blob([data], {
            type: 'image/svg+xml;charset=utf-8'
            });
            const url = DOMURL.createObjectURL(svg);

            img.onload = function() {
                tooltipCtx.drawImage(img, x, y);
                DOMURL.revokeObjectURL(url);
            }

            img.src = url;
        }

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        getRange();
        drawHorizontalLines();
        drawYAxis();
        generateColumns();
        generateXAxisLabel(xAxisPosition);

        graphElement.addEventListener('mousemove', (evt) => {
            const mousePosition = getMousePos(graphElement, evt);
            const mouseX = mousePosition.x;
            const mouseY = mousePosition.y;
            let hit = false;
            for(let i=0; i<tooltipData.length; i++) {
                // tooltipCtx.clearRect(0, 0, tooltipCanvas.width, tooltipCanvas.height);
                // tooltipCanvas.style.left = "-200px";
                if(mouseX > tooltipData[i].x && mouseX < tooltipData[i].x1 && mouseY > tooltipData[i].y && mouseY < tooltipData[i].y1) {
                    tooltipCanvas.style.display = 'block';
                    if(!tooltipTemplate) {
                        tooltipCanvas.style.left = (mouseX) + 5 + "px";
                        tooltipCanvas.style.top = (mouseY + 5) + "px";
                        tooltipCanvas.style.color = tooltipData[i].style.color;
                        tooltipCanvas.style.border = '1px solid ' + tooltipData[i].style.color;
                        tooltipCtx.clearRect(0, 0, tooltipCanvas.width, tooltipCanvas.height);
                        ctx.rect(0, 0, tooltipCanvas.width, tooltipCanvas.height);
                        tooltipCtx.fillText(tooltipData[i].data.y, 5, 15);
                    } else {
                        tooltipTemplate.replace('@m=x', tooltipData[i].data.x);
                        tooltipTemplate.replace('@m=y', tooltipData[i].data.y);
                        // tooltipCanvas.appendChild(tooltipTemplate);
                        renderHTMLToCanvas(tooltipTemplate, 0, 0, tooltipCanvas.width, tooltipCanvas.height);
                    }
                    hit = true;
                }
            }
            if (!hit) {
                tooltipCanvas.style.display = 'none';
            }
        });
    </script>
</html>